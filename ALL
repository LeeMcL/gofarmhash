// farmhash project doc.go

/*
farmhash document
*/
package farmhash
// farmhash Googles hash algorithm

/*
Farmash is a successor to Cityhash

This code is just a conversion of Googles C++ into go and moved around a bit
to implement the hash interface
*/
package farmhash

import (
	_ "lmmrtech.com/lee/farmhash/cc"
	_ "lmmrtech.com/lee/farmhash/fh"
	_ "lmmrtech.com/lee/farmhash/mk"
	"lmmrtech.com/lee/farmhash/na"
	"lmmrtech.com/lee/farmhash/su"
)

const (
	Version = "1.1"
)

// Note: The original code has a lot of endian checking going on but
// I converted only the little endian version.  So its possibly it will fail
// on bigendian platforms but my reading of the code is the endian stuff is
// only used when testing

type Farmhash32 struct {
}

type Farmhash64 struct {
}

func (f *Farmhash32) Reset() {
}

func Hash32(s []byte, len int) uint32 {
	if len <= 256 {
		return uint32(na.Hash64(s, uint64(len)))
	}
	return su.Hash32(s, len)
}

func Hash32WithSeed(s []byte, len int, seed uint32) uint32 {
	if len <= 256 {
		return uint32(na.Hash64WithSeed(s, uint64(len), uint64(seed)))
	}
	return su.Hash32WithSeed(s, uint64(len), seed)
}
// This file provides a 32-bit hash equivalent to CityHash32 (v1.1.1)
// and a 128-bit hash equivalent to CityHash128 (v1.1.1).  It also provides
// a seeded 32-bit hash function similar to CityHash32.
package cc

import (
	"encoding/binary"
	. "lmmrtech.com/lee/farmhash/fh"
	"lmmrtech.com/lee/farmhash/mk"
)

const (
	Version = "1.1"
)

func Hash32Len13to24(s []byte, len uint64) uint32 {
	a := binary.LittleEndian.Uint32(s[-4+int64(len>>1):])
	b := binary.LittleEndian.Uint32(s[4:])
	c := binary.LittleEndian.Uint32(s[len-8:])
	d := binary.LittleEndian.Uint32(s[len>>1:])
	e := binary.LittleEndian.Uint32(s[0:])
	f := binary.LittleEndian.Uint32(s[len-4:])
	h := uint32(len)
	return Fmix(Mur(f, Mur(e, Mur(d, Mur(c, Mur(b, Mur(a, h)))))))
	return 0
}

func hash32Len0to4(s []byte, len uint64) uint32 {
	var b uint32 = 0
	var c uint32 = 9
	var i uint64
	for i = 0; i < len; i++ {
		//var v int8
		v := int8(s[i])
		b = b*C1 + uint32(v)
		c ^= b
	}
	return Fmix(Mur(b, Mur(uint32(len), c)))
}

func hash32Len5to12(s []byte, len uint64) uint32 {
	var a, b, c, d uint32
	a = uint32(len)
	b = uint32(len * 5)
	c = 9
	d = b
	a += binary.LittleEndian.Uint32(s[0:])
	b += binary.LittleEndian.Uint32(s[len-4:])
	c += binary.LittleEndian.Uint32(s[((len >> 1) & 4):])
	return Fmix(Mur(c, Mur(b, Mur(a, d))))
}

func hash32(s []byte, len uint64) uint32 {
	if len <= 24 {
		if len <= 12 {
			if len <= 4 {
				return hash32Len0to4(s, len)
			}
			return hash32Len5to12(s, len)
		}
		return Hash32Len13to24(s, len)
	}

	// len > 24
	var h, g, f uint32
	h = uint32(len)
	g = C1 * uint32(len)
	f = g
	a0 := Rotate32(binary.LittleEndian.Uint32(s[len-4:])*C1, 17) * C2
	a1 := Rotate32(binary.LittleEndian.Uint32(s[len-8:])*C1, 17) * C2
	a2 := Rotate32(binary.LittleEndian.Uint32(s[len-16:])*C1, 17) * C2
	a3 := Rotate32(binary.LittleEndian.Uint32(s[len-12:])*C1, 17) * C2
	a4 := Rotate32(binary.LittleEndian.Uint32(s[len-20:])*C1, 17) * C2
	h ^= a0
	h = Rotate32(h, 19)
	h = h*5 + 0xe6546b64
	h ^= a2
	h = Rotate32(h, 19)
	h = h*5 + 0xe6546b64
	g ^= a1
	g = Rotate32(g, 19)
	g = g*5 + 0xe6546b64
	g ^= a3
	g = Rotate32(g, 19)
	g = g*5 + 0xe6546b64
	f += a4
	f = Rotate32(f, 19)
	f = f*5 + 0xe6546b64

	var iters uint64 = (len - 1) / 20
	for {
		a0 := Rotate32(binary.LittleEndian.Uint32(s[:])*C1, 17) * C2
		a1 := binary.LittleEndian.Uint32(s[4:])
		a2 := Rotate32(binary.LittleEndian.Uint32(s[8:])*C1, 17) * C2
		a3 := Rotate32(binary.LittleEndian.Uint32(s[12:])*C1, 17) * C2
		a4 := binary.LittleEndian.Uint32(s[16:])
		h ^= a0
		h = Rotate32(h, 18)
		h = h*5 + 0xe6546b64
		f += a1
		f = Rotate32(f, 19)
		f = f * C1
		g += a2
		g = Rotate32(g, 18)
		g = g*5 + 0xe6546b64
		h ^= a3 + a1
		h = Rotate32(h, 19)
		h = h*5 + 0xe6546b64
		g ^= a4
		g = Bswap32(g) * 5
		h += a4 * 5
		h = Bswap32(h)
		f += a0
		//PERMUTE3(f, h, g) - swap(a,b);swap(b,c)
		f, h = h, f
		f, g = g, f
		s = s[20:]
		if iters--; iters == 0 {
			break
		}
	}
	g = Rotate32(g, 11) * C1
	g = Rotate32(g, 17) * C1
	f = Rotate32(f, 11) * C1
	f = Rotate32(f, 17) * C1
	h = Rotate32(h+g, 19)
	h = h*5 + 0xe6546b64
	h = Rotate32(h, 17) * C1
	h = Rotate32(h+f, 19)
	h = h*5 + 0xe6546b64
	h = Rotate32(h, 17) * C1
	return h
}

func Hash32WithSeed(s []byte, len uint64, seed uint32) uint32 {
	if len <= 24 {
		if len >= 13 {
			return mk.Hash32Len13to24(s, len, seed*C1)
		} else if len >= 5 {
			return mk.Hash32Len5to12(s, len, seed)
		} else {
			return mk.Hash32Len0to4(s, len, seed)
		}
	}
	h := mk.Hash32Len13to24(s, 24, seed^uint32(len))
	return Mur(hash32(s[24:], len-24)+seed, h)
}

func shiftMix(val uint64) uint64 {
	return val ^ (val >> 47)
}

func hashLen16NoMul(u, v uint64) uint64 {
	return Hash128to64(Uint128{u, v})
}

func hashLen16(u, v, mul uint64) uint64 {
	// Murmur-inspired hashing.
	a := (u ^ v) * mul
	a ^= (a >> 47)
	b := (v ^ a) * mul
	b ^= (b >> 47)
	b *= mul
	return b
}

func hashLen0to16(s []byte, len uint64) uint64 {
	if len >= 8 {
		var mul, a, b, c, d uint64
		mul = K2 + uint64(len)*2
		a = binary.LittleEndian.Uint64(s) + K2
		b = binary.LittleEndian.Uint64(s[len-8:])
		c = Rotate64(b, 37)*mul + a
		d = (Rotate64(a, 25) + b) * mul
		return hashLen16(c, d, mul)
	}
	if len >= 4 {
		var mul, a uint64
		mul = K2 + uint64(len)*2
		a = uint64(binary.LittleEndian.Uint32(s))
		return hashLen16(uint64(len)+(a<<3), uint64(binary.LittleEndian.Uint32(s[len-4:])), mul)
	}
	if len > 0 {
		var a, b, c uint8
		a = s[0]
		b = s[len>>1]
		c = s[len-1]
		var y, z uint32
		y = uint32(a) + (uint32(b) << 8)
		z = uint32(len) + (uint32(c) << 2)
		return shiftMix(uint64(y)*K2^uint64(z)*K0) * uint64(K2)
	}
	return K2
}

// Return a 16-byte hash for 48 bytes.  Quick and dirty.
// Callers do best to use "random-looking" values for a and b.
// Note: original C++ returned a pair<uint64_t, uint64_t>
func WeakHashLen32WithSeeds(w, x, y, z, a, b uint64) Uint128 {
	a += w
	b = Rotate64(b+a+z, 21)
	c := a
	a += x
	a += y
	b += Rotate64(a, 44)
	return Uint128{a + z, b + c}
}

// Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
// Note: original C++ returned a pair<uint64_t, uint64_t>
func WeakHashLen32WithSeedsBytes(s []byte, a, b uint64) Uint128 {
	return WeakHashLen32WithSeeds(binary.LittleEndian.Uint64(s),
		binary.LittleEndian.Uint64(s[8:]),
		binary.LittleEndian.Uint64(s[16:]),
		binary.LittleEndian.Uint64(s[24:]),
		a,
		b)
}

// A subroutine for CityHash128().  Returns a decent 128-bit hash for strings
// of any length representable in signed long.  Based on City and Murmur.
func CityMurmur(s []byte, len uint64, seed Uint128) Uint128 {
	a := seed.First
	b := seed.Second
	var c uint64 = 0
	var d uint64 = 0
	l := int64(len - 16)
	if l <= 0 { // len <= 16
		a = shiftMix(a*K1) * K1
		c = b*K1 + hashLen0to16(s, len)
		if len >= 8 {
			d = shiftMix(a + binary.LittleEndian.Uint64(s))
		} else {
			d = shiftMix(a + c)
		}
	} else { // len > 16
		c = hashLen16NoMul(binary.LittleEndian.Uint64(s[(len-8):])+K1, a)
		d = hashLen16NoMul(b+len, c+binary.LittleEndian.Uint64(s[len-16:]))
		a += d
		for {
			a ^= shiftMix(binary.LittleEndian.Uint64(s)*K1) * K1
			a *= K1
			b ^= a
			c ^= shiftMix(binary.LittleEndian.Uint64(s[8:])*K1) * K1
			c *= K1
			d ^= c
			s = s[16:]
			l -= 16
			if l <= 0 {
				break
			}
		}
	}
	a = hashLen16NoMul(a, c)
	b = hashLen16NoMul(d, b)
	return Uint128{a ^ b, hashLen16NoMul(b, a)}
}

func CityHash128WithSeed(s []byte, len uint64, seed Uint128) Uint128 {
	if len < 128 {
		return CityMurmur(s, len, seed)
	}

	// We expect len >= 128 to be the common case.  Keep 56 bytes of state:
	// v, w, x, y, and z.
	// Note: v and w were pair<uint64_t, uint64_t> in the C++
	var v, w Uint128
	x := seed.First
	y := seed.Second
	z := len * K1
	v.First = Rotate64(y^K1, 49)*K1 + binary.LittleEndian.Uint64(s)
	v.Second = Rotate64(v.First, 42)*K1 + binary.LittleEndian.Uint64(s[8:])
	w.First = Rotate64(y+z, 35)*K1 + x
	w.Second = Rotate64(x+binary.LittleEndian.Uint64(s[88:]), 53) * K1

	// This is the same inner loop as CityHash64(), manually unrolled.
	for {
		x = Rotate64(x+y+v.First+binary.LittleEndian.Uint64(s[8:]), 37) * K1
		y = Rotate64(y+v.Second+binary.LittleEndian.Uint64(s[48:]), 42) * K1
		x ^= w.Second
		y += v.First + binary.LittleEndian.Uint64(s[40:])
		z = Rotate64(z+w.First, 33) * K1
		v = WeakHashLen32WithSeedsBytes(s, v.Second*K1, x+w.First)
		w = WeakHashLen32WithSeedsBytes(s[32:], z+w.Second, y+binary.LittleEndian.Uint64(s[16:]))
		z, x = x, y
		s = s[64:]
		x = Rotate64(x+y+v.First+binary.LittleEndian.Uint64(s[8:]), 37) * K1
		y = Rotate64(y+v.Second+binary.LittleEndian.Uint64(s[48:]), 42) * K1
		x ^= w.Second
		y += v.First + binary.LittleEndian.Uint64(s[40:])
		z = Rotate64(z+w.First, 33) * K1
		v = WeakHashLen32WithSeedsBytes(s, v.Second*K1, x+w.First)
		w = WeakHashLen32WithSeedsBytes(s[32:], z+w.Second, y+binary.LittleEndian.Uint64(s[16:]))
		z, x = x, y
		s = s[64:]
		len -= 128
		if len < 128 {
			break
		}
	}
	x += Rotate64(v.First+z, 49) * K0
	y = y*K0 + Rotate64(w.Second, 37)
	z = z*K0 + Rotate64(w.First, 27)
	w.First *= 9
	v.First *= K0
	// If 0 < len < 128, hash up to 4 chunks of 32 bytes each from the end of s.
	var tail_done uint64
	for tail_done = 0; tail_done < len; {
		tail_done += 32
		y = Rotate64(x+y, 42)*K0 + v.Second
		w.First += binary.LittleEndian.Uint64(s[len-tail_done+16:])
		x = x*K0 + w.First
		z += w.Second + binary.LittleEndian.Uint64(s[len-tail_done:])
		w.Second += v.First
		v = WeakHashLen32WithSeedsBytes(s[len-tail_done:], v.First+z, v.Second)
		v.First *= K0
	}
	// At this point our 56 bytes of state should contain more than
	// enough information for a strong 128-bit hash.  We use two
	// different 56-byte-to-8-byte hashes to get a 16-byte final result.
	x = hashLen16NoMul(x, v.First)
	y = hashLen16NoMul(y+z, w.First)
	return Uint128{hashLen16NoMul(x+v.Second, w.Second) + y,
		hashLen16NoMul(x+w.Second, y+v.Second)}
}

func CityHash128(s []byte, len uint64) Uint128 {
	if len >= 16 {
		return CityHash128WithSeed(s[16:], len-16,
			Uint128{binary.LittleEndian.Uint64(s), binary.LittleEndian.Uint64(s[8:]) + K0})

	}
	return CityHash128WithSeed(s, len, Uint128{K0, K1})
}

func Fingerprint128(s []byte, len uint64) Uint128 {
	return CityHash128(s, len)
}
package fh

const (
	// Some primes between 2^63 and 2^64 for various uses.
	K0 uint64 = 0xc3a5c85c97cb3127
	K1 uint64 = 0xb492b66fbe98f273
	K2 uint64 = 0x9ae16a3b2f90404f

	// Magic numbers for 32-bit hashing.  Copied from Murmur3.
	C1 uint32 = 0xcc9e2d51
	C2 uint32 = 0x1b873593
)

// fmix is a 32-bit to 32-bit integer hash copied from Murmur3.
func Fmix(h uint32) uint32 {
	h ^= h >> 16
	h *= 0x85ebca6b
	h ^= h >> 13
	h *= 0xc2b2ae35
	h ^= h >> 16
	return h
}

// mur is a helper from Murmur3 for combining two 32-bit values.
func Mur(a, h uint32) uint32 {
	a *= C1
	a = Rotate32(a, 17)
	a *= C2
	h ^= a
	h = Rotate32(h, 19)
	return h*5 + 0xe6546b64
}

// Couldn't find a version of these already in Go
func Bswap32(x uint32) uint32 {
	return ((x >> 24) & 0xFF) | ((x >> 8) & 0xFF00) | ((x << 8) & 0xFF0000) | ((x << 24) & 0xFF000000)
}

type Uint128 struct {
	First, Second uint64
}

// This is intended to be a reasonably good hash function.
func Hash128to64(x Uint128) uint64 {
	// Murmur-inspired hashing.
	const kMul uint64 = 0x9ddfea08eb382d69
	a := (x.First ^ x.Second) * kMul
	a ^= (a >> 47)
	b := (x.Second ^ a) * kMul
	b ^= (b >> 47)
	b *= kMul
	return b
}

// Note I dropped the DebugTweak templates
// Building blocks for hash functions
// In the rest of the farmhash package this is imported with:
//  import . "lmmrtech.com/lee/farmhash/fh"
package fh
// platform.go based on the original C++ platform.cc
package fh

// Instead of Fetch defined in the original C++ Go uses binary.LittleEndian

func Rotate32(val uint32, shift uint) uint32 {
	if shift == 0 {
		return val
	}
	return val>>shift | val<<(32-shift)
}

func Rotate64(val uint64, shift uint) uint64 {
	if shift == 0 {
		return val
	}
	return val>>shift | val<<(64-shift)
}
package mk

import (
	"encoding/binary"
	. "lmmrtech.com/lee/farmhash/fh"
)

func Hash32Len13to24(s []byte, len uint64, seed uint32) uint32 {
	a := binary.LittleEndian.Uint32(s[4+(len>>1):])
	b := binary.LittleEndian.Uint32(s[4:])
	c := binary.LittleEndian.Uint32(s[len-8:])
	d := binary.LittleEndian.Uint32(s[len>>1:])
	e := binary.LittleEndian.Uint32(s)
	f := binary.LittleEndian.Uint32(s[len-4:])
	h := d*C1 + uint32(len) + seed
	a = Rotate32(a, 12) + f
	h = Mur(c, h) + a
	a = Rotate32(a, 3) + c
	h = Mur(e, h) + a
	a = Rotate32(a+f, 12) + d
	h = Mur(b^seed, h) + a
	return Fmix(h)
}

func Hash32Len0to4(s []byte, len uint64, seed uint32) uint32 {
	b := seed
	var c uint32 = 9
	var i uint64
	for i = 0; i < len; i++ {
		v := int8(s[i])
		b = b*C1 + uint32(v)
		c ^= b
	}
	return Fmix(Mur(b, Mur(uint32(len), c)))
}

func Hash32Len5to12(s []byte, len uint64, seed uint32) uint32 {
	var a, b, c, d uint32
	a = uint32(len)
	b = uint32(len) * 5
	c = 9
	d = b + seed
	a += binary.LittleEndian.Uint32(s)
	b += binary.LittleEndian.Uint32(s[len-4:])
	c += binary.LittleEndian.Uint32(s[(len>>1)&4:])
	return Fmix(seed ^ Mur(c, Mur(b, Mur(a, d))))
}

func Hash32(s []byte, len uint64) uint32 {
	if len <= 24 {
		if len <= 12 {
			if len <= 4 {
				return Hash32Len0to4(s, len, 0)
			}
			return Hash32Len5to12(s, len, 0)
		}
		return Hash32Len13to24(s, len, 0)
	}

	// len > 24
	var h, g, f uint32
	h = uint32(len)
	g = C1 * uint32(len)
	f = g
	a0 := Rotate32(binary.LittleEndian.Uint32(s[len-4:])*C1, 17) * C2
	a1 := Rotate32(binary.LittleEndian.Uint32(s[len-8:])*C1, 17) * C2
	a2 := Rotate32(binary.LittleEndian.Uint32(s[len-16:])*C1, 17) * C2
	a3 := Rotate32(binary.LittleEndian.Uint32(s[len-12:])*C1, 17) * C2
	a4 := Rotate32(binary.LittleEndian.Uint32(s[len-20:])*C1, 17) * C2
	h ^= a0
	h = Rotate32(h, 19)
	h = h*5 + 0xe6546b64
	h ^= a2
	h = Rotate32(h, 19)
	h = h*5 + 0xe6546b64
	g ^= a1
	g = Rotate32(g, 19)
	g = g*5 + 0xe6546b64
	g ^= a3
	g = Rotate32(g, 19)
	g = g*5 + 0xe6546b64
	f += a4
	f = Rotate32(f, 19) + 113
	var iters uint64
	iters = (len - 1) / 20
	for {
		a := binary.LittleEndian.Uint32(s)
		b := binary.LittleEndian.Uint32(s[4:])
		c := binary.LittleEndian.Uint32(s[8:])
		d := binary.LittleEndian.Uint32(s[12:])
		e := binary.LittleEndian.Uint32(s[16:])
		h += a
		g += b
		f += c
		h = Mur(d, h) + e
		g = Mur(c, g) + a
		f = Mur(b+e*C1, f) + d
		f += g
		g += f
		s = s[20:]
		if iters--; iters == 0 {
			break
		}
	}
	g = Rotate32(g, 11) * C1
	g = Rotate32(g, 17) * C1
	f = Rotate32(f, 11) * C1
	f = Rotate32(f, 17) * C1
	h = Rotate32(h+g, 19)
	h = h*5 + 0xe6546b64
	h = Rotate32(h, 17) * C1
	h = Rotate32(h+f, 19)
	h = h*5 + 0xe6546b64
	h = Rotate32(h, 17) * C1
	return h
}

func Hash32WithSeed(s []byte, len uint64, seed uint32) uint32 {
	if len <= 24 {
		if len >= 13 {
			return Hash32Len13to24(s, len, seed*C1)
		} else if len >= 5 {
			return Hash32Len5to12(s, len, seed)
		} else {
			return Hash32Len0to4(s, len, seed)
		}
	}
	h := Hash32Len13to24(s, 24, seed^uint32(len))
	return Mur(Hash32(s[24:], len-24)+seed, h)
}
package na

import (
	"encoding/binary"
	. "lmmrtech.com/lee/farmhash/fh"
)

func shiftMix(val uint64) uint64 {
	return val ^ (val >> 47)
}

func HashLen16(u, v uint64) uint64 {
	return Hash128to64(Uint128{u, v})
}

func HashLen16Mul(u, v, mul uint64) uint64 {
	// Murmur-inspired hashing.
	a := (u ^ v) * mul
	a ^= (a >> 47)
	b := (v ^ a) * mul
	b ^= (b >> 47)
	b *= mul
	return b
}

func HashLen0to16(s []byte, len uint64) uint64 {
	if len >= 8 {
		mul := K2 + len*2
		a := binary.LittleEndian.Uint64(s) + K2
		b := binary.LittleEndian.Uint64(s[len-8:])
		c := Rotate64(b, 37)*mul + a
		d := (Rotate64(a, 25) + b) * mul
		return HashLen16Mul(c, d, mul)
	}
	if len >= 4 {
		mul := K2 + len*2
		a := binary.LittleEndian.Uint32(s)
		return HashLen16Mul(len+(uint64(a)<<3), uint64(binary.LittleEndian.Uint32(s[len-4:])), mul)
	}
	if len > 0 {
		a := s[0]
		b := s[len>>1]
		c := s[len-1]
		y := uint32(a) + (uint32(b) << 8)
		var z uint64 = len + (uint64(c) << 2)
		return shiftMix(uint64(y)*K2^z*K0) * K2
	}
	return K2
}

// This probably works well for 16-byte strings as well, but it may be overkill
// in that case.
func HashLen17to32(s []byte, len uint64) uint64 {
	mul := K2 + len*2
	a := binary.LittleEndian.Uint64(s) * K1
	b := binary.LittleEndian.Uint64(s[8:])
	c := binary.LittleEndian.Uint64(s[len-8:]) * mul
	d := binary.LittleEndian.Uint64(s[len-16:]) * K2
	return HashLen16Mul(Rotate64(a+b, 43)+Rotate64(c, 30)+d,
		a+Rotate64(b+K2, 18)+c, mul)
}

// Return a 16-byte hash for 48 bytes.  Quick and dirty.
// Callers do best to use "random-looking" values for a and b.
// Note: C++ returned pair<uint64_t, uint64_t>
func WeakHashLen32WithSeeds(w, x, y, z, a, b uint64) Uint128 {
	a += w
	b = Rotate64(b+a+z, 21)
	c := a
	a += x
	a += y
	b += Rotate64(a, 44)
	return Uint128{a + z, b + c}
}

// Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.
// Note: C++ returned pair<uint64_t, uint64_t>
func WeakHashLen32WithSeedsBytes(s []byte, a uint64, b uint64) Uint128 {
	return WeakHashLen32WithSeeds(binary.LittleEndian.Uint64(s),
		binary.LittleEndian.Uint64(s[8:]),
		binary.LittleEndian.Uint64(s[16:]),
		binary.LittleEndian.Uint64(s[24:]),
		a,
		b)
}

// Return an 8-byte hash for 33 to 64 bytes.
func HashLen33to64(s []byte, len uint64) uint64 {
	mul := K2 + len*2
	a := binary.LittleEndian.Uint64(s) * K2
	b := binary.LittleEndian.Uint64(s[8:])
	c := binary.LittleEndian.Uint64(s[len-8:]) * mul
	d := binary.LittleEndian.Uint64(s[len-16:]) * K2
	y := Rotate64(a+b, 43) + Rotate64(c, 30) + d
	z := HashLen16Mul(y, a+Rotate64(b+K2, 18)+c, mul)
	e := binary.LittleEndian.Uint64(s[16:]) * mul
	f := binary.LittleEndian.Uint64(s[24:])
	g := (y + binary.LittleEndian.Uint64(s[len-32:])) * mul
	h := (z + binary.LittleEndian.Uint64(s[len-24:])) * mul
	return HashLen16Mul(Rotate64(e+f, 43)+Rotate64(g, 30)+h,
		e+Rotate64(f+a, 18)+g, mul)
}

func Hash64(s []byte, len uint64) uint64 {
	const seed uint64 = 81
	if len <= 32 {
		if len <= 16 {
			return HashLen0to16(s, len)
		} else {
			return HashLen17to32(s, len)
		}
	} else if len <= 64 {
		return HashLen33to64(s, len)
	}

	// For strings over 64 bytes we loop.  Internal state consists of
	// 56 bytes: v, w, x, y, and z.
	x := seed
	// This overflows a qint64
	// y := (seed*K1) + 113
	y := seed
	y *= K1
	y += 113
	z := shiftMix(y*K2+113) * K2
	// v and w were pair<uint64_t, uint64_t>
	var v, w Uint128
	x = x*K2 + binary.LittleEndian.Uint64(s)

	// Set end so that after the loop we have 1 to 64 bytes left to process.
	var end uint64 = ((len - 1) / 64) * 64
	var last64 uint64 = end + ((len - 1) & 63) - 63
	var i uint64
	for {
		x = Rotate64(x+y+v.First+binary.LittleEndian.Uint64(s[8:]), 37) * K1
		y = Rotate64(y+v.Second+binary.LittleEndian.Uint64(s[48:]), 42) * K1
		x ^= w.Second
		y += v.First + binary.LittleEndian.Uint64(s[40:])
		z = Rotate64(z+w.First, 33) * K1
		v = WeakHashLen32WithSeedsBytes(s, v.Second*K1, x+w.First)
		w = WeakHashLen32WithSeedsBytes(s[32:], z+w.Second, y+binary.LittleEndian.Uint64(s[16:]))
		z, x = x, z
		s = s[64:]
		i += 64
		if i == end {
			break
		}
	}
	mul := K1 + ((z & 0xff) << 1)
	// Make s point to the last 64 bytes of input.
	s = s[last64:]
	w.First += ((len - 1) & 63)
	v.First += w.First
	w.First += v.First
	x = Rotate64(x+y+v.First+binary.LittleEndian.Uint64(s[8:]), 37) * mul
	y = Rotate64(y+v.Second+binary.LittleEndian.Uint64(s[48:]), 42) * mul
	x ^= w.Second * 9
	y += v.First*9 + binary.LittleEndian.Uint64(s[40:])
	z = Rotate64(z+w.First, 33) * mul
	v = WeakHashLen32WithSeedsBytes(s, v.Second*mul, x+w.First)
	w = WeakHashLen32WithSeedsBytes(s[32:], z+w.Second, y+binary.LittleEndian.Uint64(s[16:]))
	z, x = x, z
	return HashLen16Mul(HashLen16Mul(v.First, w.First, mul)+shiftMix(y)*K0+z,
		HashLen16Mul(v.Second, w.Second, mul)+x,
		mul)
}

func Hash64WithSeed(s []byte, len uint64, seed uint64) uint64 {
	return Hash64WithSeeds(s, len, K2, seed)
}

func Hash64WithSeeds(s []byte, len, seed0, seed1 uint64) uint64 {
	return HashLen16(Hash64(s, len)-seed0, seed1)
}
package su

